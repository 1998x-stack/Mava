# python3
# Copyright 2021 InstaDeep Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""Core Mava interfaces."""

import abc
from types import SimpleNamespace
from typing import Any, Dict, Iterator, List, Optional, Sequence, Tuple, TypeVar, Union

import dm_env
import numpy as np
import reverb
import sonnet as snt
from acme import core as acme_core
from acme import types

from mava import adders

T = TypeVar("T")


class SystemExecutor(abc.ABC):
    """Abstract system executor object."""

    @abc.abstractmethod
    def _policy(
        self, agent: str, observation: types.NestedTensor
    ) -> types.NestedTensor:
        """Agent specific policy function"""

    @abc.abstractmethod
    def select_action(
        self, agent: str, observation: types.NestedArray
    ) -> Union[types.NestedArray, Tuple[types.NestedArray, types.NestedArray]]:
        """select an action for a single agent in the system"""

    @abc.abstractmethod
    def observe_first(
        self,
        timestep: dm_env.TimeStep,
        extras: Dict[str, types.NestedArray] = {},
    ) -> None:
        """record first observed timestep from the environment"""

    @abc.abstractmethod
    def observe(
        self,
        actions: Dict[str, types.NestedArray],
        next_timestep: dm_env.TimeStep,
        next_extras: Dict[str, types.NestedArray] = {},
    ) -> None:
        """record observed timestep from the environment"""

    @abc.abstractmethod
    def select_actions(
        self, observations: Dict[str, types.NestedArray]
    ) -> Union[
        Dict[str, types.NestedArray],
        Tuple[Dict[str, types.NestedArray], Dict[str, types.NestedArray]],
    ]:
        """select the actions for all agents in the system"""

    @abc.abstractmethod
    def update(self, wait: bool = False) -> None:
        """update executor variables"""


class SystemTrainer(abc.ABC):
    """Abstract system trainer object."""

    @abc.abstractmethod
    def _update_target_networks(self) -> None:
        """Sync the target network parameters with the latest online network
        parameters"""

    @abc.abstractmethod
    def _transform_observations(
        self, obs: Dict[str, np.ndarray], next_obs: Dict[str, np.ndarray]
    ) -> Any:
        """Transform the observations using the observation networks of each agent."""

    @abc.abstractmethod
    def _get_feed(
        self,
        transition: Dict[str, Dict[str, np.ndarray]],
        agent: str,
    ) -> Any:
        """get data to feed to the agent networks"""

    @abc.abstractmethod
    def _step(self) -> Dict:
        """Trainer forward and backward passes."""

    @abc.abstractmethod
    def _forward(self, inputs: reverb.ReplaySample) -> None:
        """Trainer forward pass"""

    @abc.abstractmethod
    def _backward(self) -> None:
        """Trainer backward pass updating network parameters"""

    @abc.abstractmethod
    def step(self) -> None:
        """trainer step to update the parameters of the agents in the system"""


class SystemBuilder(abc.ABC):
    """Abstract system builder object."""

    @abc.abstractmethod
    def tables(
        self,
    ) -> List[reverb.Table]:
        """Create tables to insert data into."""

    @abc.abstractmethod
    def dataset(
        self,
        replay_client: reverb.Client,
        table_name: str,
    ) -> Iterator[reverb.ReplaySample]:
        """Create a dataset iterator to use for training/updating the system."""

    @abc.abstractmethod
    def adder(
        self,
        replay_client: reverb.Client,
    ) -> Optional[adders.ParallelAdder]:
        """Create an adder which records data generated by the executor/environment."""

    @abc.abstractmethod
    def system(
        self,
    ) -> Tuple[Dict[str, Dict[str, snt.Module]], Dict[str, Dict[str, snt.Module]]]:
        """[summary]"""

    @abc.abstractmethod
    def variable_server(
        self,
    ) -> Any:
        """Create the variable server."""

    @abc.abstractmethod
    def executor(
        self,
        executor_id: str,
        replay_client: reverb.Client,
        variable_server: Any,
    ) -> acme_core.Worker:
        """[summary]"""

    @abc.abstractmethod
    def evaluator(
        self,
        variable_server: Any,
    ) -> Any:
        """[summary]"""
        iterator = range(num_steps) if num_steps is not None else itertools.count()
        for _ in iterator:
            self.step()
            self.after_trainer_step()

    # TODO(Arnu/Kale-ab): find a more suitable way to do this using callbacks
    def after_trainer_step(self) -> None:
        """Function that gets executed after every trainer step."""
        pass

    @abc.abstractmethod
    def trainer(
        self,
        trainer_id: str,
        replay_client: reverb.Client,
        variable_server: Any,
    ) -> SystemTrainer:
        """[summary]"""

    @abc.abstractmethod
    def build(
        self,
        program: Any,
    ) -> Any:
        """[summary]"""


class BaseSystem(abc.ABC):
    """Abstract system object."""

    # TODO (Arnu): change config type once decided what will work best.
    # e.g. dataclass or dict etc.
    @abc.abstractmethod
    def configure(self, config: Any) -> SimpleNamespace:
        """[summary]"""

    # Note (dries): Using Callback here causes a circular import issue.
    @abc.abstractmethod
    def update(self, component: Any, name: str) -> None:
        """[summary]"""

    @abc.abstractmethod
    def add(self, component: Any, name: str) -> None:
        """[summary]"""

    @abc.abstractmethod
    def build(
        self,
        num_executors: int,
        multi_process: str,
        nodes_on_gpu: List[str],
        name: str,
    ) -> None:
        """[summary]"""

    @abc.abstractmethod
    def launch(self):
        """[summary]"""


class SystemVariableServer(abc.ABC):
    """Abstract system variable manager object."""

    @abc.abstractmethod
    def get_variables(
        self, names: Union[str, Sequence[str]]
    ) -> Dict[str, Dict[str, np.ndarray]]:
        """Get variables from the variable server."""

    @abc.abstractmethod
    def set_variables(self, names: Sequence[str], vars: Dict[str, np.ndarray]) -> None:
        """Set variables in the variable server."""

    @abc.abstractmethod
    def add_to_variables(
        self, names: Sequence[str], vars: Dict[str, np.ndarray]
    ) -> None:
        """Add to the variables in the variable server."""

    @abc.abstractmethod
    def run(self) -> None:
        """Run the variable source. This function allows for
        checkpointing and other centralised computations to
        be performed by the variable server."""


class SystemVariableClient(abc.ABC):
    @abc.abstractmethod
    def get_async(self) -> None:
        """Asynchronously updates the get variables with the latest copy from source."""

    @abc.abstractmethod
    def set_async(self) -> None:
        """Asynchronously updates source with the set variables."""

    @abc.abstractmethod
    def set_and_get_async(self) -> None:
        """Asynchronously updates source and gets from source."""

    @abc.abstractmethod
    def add_async(self, names: List[str], vars: Dict[str, Any]) -> None:
        """Asynchronously adds to source variables."""

    @abc.abstractmethod
    def add_and_wait(self, names: List[str], vars: Dict[str, Any]) -> None:
        """Adds the specified variables to the corresponding variables in source
        and waits for the process to complete before continuing."""

    @abc.abstractmethod
    def get_and_wait(self) -> None:
        """Updates the get variables with the latest copy from source
        and waits for the process to complete before continuing."""

    @abc.abstractmethod
    def get_all_and_wait(self) -> None:
        """Updates all the variables with the latest copy from source
        and waits for the process to complete before continuing."""

    @abc.abstractmethod
    def set_and_wait(self) -> None:
        """Updates source with the set variables
        and waits for the process to complete before continuing."""

    @abc.abstractmethod
    def _copy(self, new_variables: Dict[str, Any]) -> None:
        """Copies the new variables to the old ones."""
