# python3
# Copyright 2021 InstaDeep Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Mava system implementation."""

from typing import Any, Dict, Iterator, List, Optional, Tuple

import launchpad as lp
import reverb

import mava
from mava import adders
from mava.callbacks import Callback, SystemCallbackHookMixin
from mava.core import SystemBuilder
from mava.systems.tf.variable_sources import VariableSource as MavaVariableSource


class Builder(SystemBuilder, SystemCallbackHookMixin):
    """MARL system."""

    def __init__(
        self,
        components: Dict[str, List[Callback]],
        config: Dict[str, Any] = {},
    ):
        """[summary]

        Args:
            components (Dict[str, Dict[str, Callback]]): [description]
        """
        self.config = config
        self.callbacks = components

        # self.components = components

        # self.callbacks = []
        # for system_components in components.values():
        #     for component in system_components.values():
        #         self.callbacks.append(component)

        self.on_builder_setup()

        # Question (dries): What is on_building_init_start used for?
        self.on_building_init_start()

        self.on_building_init()

        self.on_building_init_end()

    def tables(self) -> List[reverb.Table]:
        """ "make tables to insert data into."""

        # start of make replay tables
        self.on_building_tables_start()

        # make adder signature
        self.on_building_tables_adder_signature()

        # make rate limiter
        self.on_building_tables_rate_limiter()

        # make tables
        self.on_building_tables_make_tables()

        # end of make replay tables
        self.on_building_tables_end()

        return self._replay_tables

    def dataset(
        self,
        replay_client: reverb.Client,
        table_name: str,
    ) -> Iterator[reverb.ReplaySample]:
        """Create a dataset iterator to use for training/updating the system.
        Args:
            replay_client (reverb.Client): Reverb Client which points to the
                replay server.
        Returns:
            [type]: dataset iterator.
        Yields:
            Iterator[reverb.ReplaySample]: data samples from the dataset.
        """
        self._replay_client = replay_client
        self._table_name = table_name

        # start of make dataset iterator
        self.on_building_dataset_start()

        # make dataset
        self.on_building_dataset_make_dataset()

        # end of make dataset iterator
        self.on_building_dataset_end()

        return self.dataset

    def adder(
        self,
        replay_client: reverb.Client,
    ) -> Optional[adders.ParallelAdder]:
        """Create an adder which records data generated by the executor/environment.
        Args:
            replay_client (reverb.Client): Reverb Client which points to the
                replay server.
        Raises:
            NotImplementedError: unknown executor type.
        Returns:
            Optional[adders.ParallelAdder]: adder which sends data to a replay buffer.
        """
        self._replay_client = replay_client

        # start of make make adder
        self.on_building_adder_start()

        # make adder signature
        self.on_building_adder_set_priority()

        # make rate limiter
        self.on_building_adder_make_adder()

        # end of make adder
        self.on_building_adder_end()

        return self._adder

    def system(
        self,
    ) -> Tuple[Dict[str, Dict[str, Any]], Dict[str, Dict[str, Any]]]:
        """Initialise the system variables from the network factory."""

        self.on_building_system_start()

        self.on_building_system_networks()

        self.on_building_system_architecture()

        self.on_building_system_make_system()

        self.on_building_system_end()

        return self.system_networks

    def variable_server(self, extra_nodes={}) -> MavaVariableSource:
        """Create the variable server.
        Args:
            networks (Dict[str, Dict[str, Any]]): dictionary with the
            system's networks in.
        Returns:
            variable_source (MavaVariableSource): A Mava variable source object.
        """

        # Extra nodes
        # TODO (dries): Remove this again if it is not necessary.
        self._extra_nodes = extra_nodes

        # start of make variable server
        self.on_building_variable_server_start()

        # make variable server
        self.on_building_variable_server_make_variable_server()

        # end of make variable server
        self.on_building_variable_server_end()

        return self.variable_server

    def executor(
        self,
        executor_id: str,
        replay_client: reverb.Client,
        variable_source: MavaVariableSource,
    ) -> mava.ParallelEnvironmentLoop:
        """System executor
        Args:
            executor_id (str): id to identify the executor process for logging purposes.
            replay (reverb.Client): replay data table to push data to.
            variable_source (acme.VariableSource): variable server for updating
                network variables.
            counter (counting.Counter): step counter object.
        Returns:
            mava.ParallelEnvironmentLoop: environment-executor loop instance.
        """

        self._executor_id = executor_id
        self._replay_client = replay_client
        self._variable_source = variable_source

        self.on_building_executor_start()

        self.on_building_executor_logger()

        self.on_building_executor_variable_client()

        self.on_building_executor_make_executor()

        self.on_building_executor_environment()

        self.on_building_executor_train_loop()

        self.on_building_executor_end()

        return self.train_loop

    def evaluator(
        self,
        variable_source: MavaVariableSource,
    ) -> Any:
        """System evaluator (an executor process not connected to a dataset)
        Args:
            variable_source (acme.VariableSource): variable server for updating
                network variables.
            counter (counting.Counter): step counter object.
        Returns:
            Any: environment-executor evaluation loop instance for evaluating the
                performance of a system.
        """

        self._variable_source = variable_source

        self.on_building_evaluator_start()

        self.on_building_evaluator_logger()

        self.on_building_evaluator_variable_client()

        self.on_building_evaluator_make_evaluator()

        self.on_building_evaluator_environment()

        self.on_building_evaluator_eval_loop()

        self.on_building_evaluator_end()

        return self.eval_loop

    def trainer(
        self,
        trainer_id: str,
        replay_client: reverb.Client,
        variable_source: MavaVariableSource,
    ) -> mava.core.SystemTrainer:
        """System trainer
        Args:
            replay (reverb.Client): replay data table to pull data from.
            counter (counting.Counter): step counter object.
        Returns:
            mava.core.SystemTrainer: system trainer.
        """

        self._trainer_id = trainer_id
        self._replay_client = replay_client
        self._variable_source = variable_source

        self.on_building_trainer_start()

        self.on_building_trainer_logger()

        self.on_building_trainer_dataset()

        self.on_building_trainer_variable_client()

        self.on_building_trainer_make_trainer()

        self.on_building_trainer_end()

        return self.trainer

    def add_program_nodes(self, program):
        # TODO (dries): Is it needed to specify this hook? Maybe for better readability from the user side.
        self.on_add_program_nodes(program)
